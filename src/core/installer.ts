import { join, dirname } from "node:path";
import { homedir } from "node:os";
import { LocalStorage } from "../storage/local.ts";
import { KamiError, EXIT_CODES } from "../types/result.ts";

const storage = new LocalStorage();

export type InstallTarget = "claude-code" | "codex" | "gemini";
export type InstallLevel = "project" | "user";

export const INSTALL_TARGETS: InstallTarget[] = [
  "claude-code",
  "codex",
  "gemini",
];
export const INSTALL_LEVELS: InstallLevel[] = ["project", "user"];

export const TARGET_LABELS: Record<InstallTarget, string> = {
  "claude-code": "Claude Code",
  codex: "Codex CLI",
  gemini: "Gemini CLI",
};

export interface InstallResult {
  target: InstallTarget;
  level: InstallLevel;
  files: string[];
  destination: string;
}

const MARKER_START = "<!-- kami:start -->";
const MARKER_END = "<!-- kami:end -->";

/** Get the skill source directory from the package root */
function getSkillSourceDir(): string {
  // src/core/ -> src/ -> package root -> .claude/skills/kami/
  return join(import.meta.dir, "..", "..", ".claude", "skills", "kami");
}

/** Get the destination path for Claude Code skill */
function getClaudeCodeDest(level: InstallLevel, cwd: string): string {
  return level === "project"
    ? join(cwd, ".claude", "skills", "kami")
    : join(homedir(), ".claude", "skills", "kami");
}

/** Get the destination file for Codex CLI */
function getCodexDest(level: InstallLevel, cwd: string): string {
  return level === "project"
    ? join(cwd, "AGENTS.md")
    : join(homedir(), ".codex", "instructions.md");
}

/** Get the destination file for Gemini CLI */
function getGeminiDest(level: InstallLevel, cwd: string): string {
  return level === "project"
    ? join(cwd, "GEMINI.md")
    : join(homedir(), ".gemini", "GEMINI.md");
}

/** Strip YAML frontmatter from markdown content */
function stripFrontmatter(content: string): string {
  const match = content.match(/^---\n[\s\S]*?\n---\n/);
  return match ? content.slice(match[0].length).trim() : content.trim();
}

/** Build consolidated markdown content for Codex/Gemini */
async function buildConsolidatedContent(): Promise<string> {
  const srcDir = getSkillSourceDir();

  const skillContent = await storage.readFile(join(srcDir, "SKILL.md"));
  const articleFormat = await storage.readFile(
    join(srcDir, "reference", "article-format.md"),
  );
  const jsonExamples = await storage.readFile(
    join(srcDir, "reference", "json-examples.md"),
  );
  const errorCodes = await storage.readFile(
    join(srcDir, "reference", "error-codes.md"),
  );

  const body = stripFrontmatter(skillContent);

  return [
    MARKER_START,
    "<!-- Auto-generated by: kami install -->",
    "",
    body,
    "",
    "---",
    "",
    articleFormat.trim(),
    "",
    "---",
    "",
    jsonExamples.trim(),
    "",
    "---",
    "",
    errorCodes.trim(),
    "",
    MARKER_END,
  ].join("\n");
}

/** Install kami skill for Claude Code (directory with multiple files) */
async function installClaudeCode(
  level: InstallLevel,
  cwd: string,
  force: boolean,
): Promise<InstallResult> {
  const dest = getClaudeCodeDest(level, cwd);
  const skillMd = join(dest, "SKILL.md");

  if (!force && (await storage.exists(skillMd))) {
    throw new KamiError(
      `Skill already exists at ${dest}. Use --force to overwrite.`,
      "VALIDATION_ERROR",
      EXIT_CODES.GENERAL_ERROR,
    );
  }

  const srcDir = getSkillSourceDir();

  if (!(await storage.exists(join(srcDir, "SKILL.md")))) {
    throw new KamiError(
      `Skill source not found at ${srcDir}. Package may be incomplete.`,
      "IO_ERROR",
      EXIT_CODES.GENERAL_ERROR,
    );
  }

  const files: string[] = [];

  // Create directory structure
  await storage.mkdir(dest);
  await storage.mkdir(join(dest, "reference"));

  // Copy SKILL.md
  const content = await storage.readFile(join(srcDir, "SKILL.md"));
  await storage.writeFile(skillMd, content);
  files.push(skillMd);

  // Copy reference files
  const refDir = join(srcDir, "reference");
  const refFiles = await storage.listFiles(refDir, "*.md");
  for (const refFile of refFiles) {
    const name = refFile.split("/").pop()!;
    const destFile = join(dest, "reference", name);
    const refContent = await storage.readFile(refFile);
    await storage.writeFile(destFile, refContent);
    files.push(destFile);
  }

  return { target: "claude-code", level, files, destination: dest };
}

/** Install kami instructions for Codex or Gemini (single markdown file) */
async function installFlatMarkdown(
  target: "codex" | "gemini",
  level: InstallLevel,
  cwd: string,
  force: boolean,
): Promise<InstallResult> {
  const dest =
    target === "codex"
      ? getCodexDest(level, cwd)
      : getGeminiDest(level, cwd);

  const kamiContent = await buildConsolidatedContent();

  // Ensure parent directory exists
  await storage.mkdir(dirname(dest));

  if (await storage.exists(dest)) {
    const existing = await storage.readFile(dest);

    if (existing.includes(MARKER_START)) {
      if (!force) {
        throw new KamiError(
          `kami section already exists in ${dest}. Use --force to overwrite.`,
          "VALIDATION_ERROR",
          EXIT_CODES.GENERAL_ERROR,
        );
      }
      // Replace existing section
      const startIdx = existing.indexOf(MARKER_START);
      const endIdx = existing.indexOf(MARKER_END) + MARKER_END.length;
      const before = existing.slice(0, startIdx);
      const after = existing.slice(endIdx);
      await storage.writeFile(dest, before + kamiContent + after);
    } else {
      // Append to existing file
      await storage.writeFile(
        dest,
        existing.trimEnd() + "\n\n" + kamiContent + "\n",
      );
    }
  } else {
    await storage.writeFile(dest, kamiContent + "\n");
  }

  return { target, level, files: [dest], destination: dest };
}

/** Install kami skill for the given target and level */
export async function installSkill(
  target: InstallTarget,
  level: InstallLevel,
  cwd: string,
  force: boolean,
): Promise<InstallResult> {
  if (target === "claude-code") {
    return installClaudeCode(level, cwd, force);
  }
  return installFlatMarkdown(target, level, cwd, force);
}
